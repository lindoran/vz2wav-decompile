# VZ2WAV (Linux Rewrite)
## Project Notes and Reconstruction History

This document explains how the original VZ2WAV DOS utility was analyzed,
reverse engineered, corrected, and rebuilt into a working Linux command
line tool that produces WAV files readable by real VZ-200 hardware.

The goal of this project was not to invent a new encoder. The goal was
to faithfully reproduce the exact waveform format generated by the
original DOS program, including its timing, silence padding, amplitude
levels, and byte encoding behavior.

I don't think its fair to call this Vibe Codeing - The innital reverse
was done by a LLM, but the end resulting code needed to be hand fixed
to remove parts that didn't work, certain limits had to be tweeked by
looking at the output of the original file.  For example the manual
gap generation was coded directly by me after the fact as the LLM
kept insisting that it did not line up with the code.  The same was
true with the silence levels as well as the high and low level
selections were made to asure compatibility with the existing circut.

Some licence was taken here, I have converted the output to square
waves because it makes calculating the waveforms more simple,
and also modern DAC's / Sound Cards seem to perform better with these
old tape circuts, using a square wave.

---

## Background

The original VZ2WAV.EXE is a DOS utility, likely compiled with Borland C.
It converts .VZ files into cassette-loadable .WAV audio for the VZ-200
and VZ-300 computers. The output is a 22050 Hz, 8-bit mono WAV file with
very specific timing and structure.

I beleve now that the code probibly was written by Brian Murray, creator
of the VZ format.  I included the source code vzread.c

The binary was decompiled using Reko, and the resulting C-like output
was analyzed to understand the original behavior.

one of the bigest issues of this kind of project is the C code that is output
is one flat file, that includes all of the library code, along with the
main file code.  One approach is to tell the LLM to simply generate only
the main file code, and eliminate at least the standard library as well as
the system calls.  We didn't take that aproach here, to start out I probibly
would have done that just to see the results if I had it to do again.


---

## Initial LLM Analysis

The first pass identified the structure of the original `_main()` routine:

- Lines 4851-4853 Prints banner/header
- Line 4862 Opens the input .VZ file
- Line 4874 Reads the 24-byte VZ header
- Lines 4877-4884 Reads data bytes until EOF
- Line 4893 Opens the output WAV file
- Lines 4902-4911 Writes a 44-byte WAV header
- Lines 4913-4921 Writes 22050 bytes of silence
- Lines 4923-4936 Writes the preamble (255 bytes of 0x80, then 5 bytes of 0xFF)
- Lines 4938-5003 Writes encoded data using `_wrVZbyte()`
- Lines 5005-5012 Writes another 22050 bytes of silence

This analysis was correct, but the first generated rewrite was not.

---

## Problems With the First Rewrite

The initial LLM-generated code had several issues:

- Output sample rate was 44100 Hz instead of 22050 Hz
- Used amplitude values from unrelated online tools
- Skipped the required gap between the preamble and the data
- Misinterpreted the VZ header
- Produced WAV files that looked valid but were unreadable by real VZ
  hardware

A more constrained prompt was required:
**"Use only the decompiled source. Do not invent new behavior."**

---

## Refining the Output

After further prompting and corrections:

- Sample rate fixed to 22050 Hz
- Output changed to square waves
- Correct amplitude values enforced:
  - HIGH = 195
  - LOW  = 61
  - SILENCE = 127
- The missing null gap between preamble and data was restored
  - I beleve this bit is actually an initialization bug from borland, but
    it turns out to be a feature.  As without this change the system never
    sees the end of the gap.
  - VZ's own cirucut, and BIOS actually uses value 0 for silence, 0 for low
    and 255 for high, but when we try to use perfect low / high values with
    the timing we are using it flat out doesn't work.
  - I think the reason for this is artifacts that are produced from the sound
    card.  I can't see any huge difference between the data generated by
    recording and data that is synthisized - realistically we are making
    modem tones using a sound card and not a tape player -- there's huge
    differences there.
- VZ file parsing was corrected (mostly)

At this stage, the output WAV files were readable by WAV2VZ_2.EXE, which
meant the structure was close, but still not accepted by real hardware.

---

## Emulator Reference (Soundpaint VZ200)

To cross-check behavior, the Java-based VZ200 emulator at:

https://github.com/soundpaint/VZ200-Emulator

was examined. Relevant file handling code was extracted and analyzed.

This helped identify:

- .VZ file handing
- some more insite on how wav files are converted to .vz

This allowed the rewrite to converge further toward correct behavior.

---

## Final Manual Fixes

The last remaining issues were only visible by opening the generated WAV
files in a hex editor and comparing them byte-for-byte with the DOS
tool's output.

Manual fixes included:

- Correcting silence values
- Fixing the exact length of the inter-section gaps
- Ensuring the preamble matched the original DOS behavior exactly

Once these were corrected, the resulting Linux tool produced WAV files
that:

- Load successfully on real VZ-200 hardware
- Round-trip through WAV2VZ_2.EXE
- Match the timing and amplitude of the original DOS encoder

---

## See the Main README

The main README in this repository explains:

- How the final code works
- The exact waveform encoding
- The structure of .VZ files
- How the Linux tool replicates the DOS behavior
- How to build and use the utility

This document captures the reconstruction history.
